# ğŸ› ï¸ å¼€å‘æŒ‡å—

æœ¬æ–‡æ¡£è¯¦ç»†ä»‹ç»é¡¹ç›®çš„æ ¸å¿ƒåŠŸèƒ½å’Œå¼€å‘æœ€ä½³å®è·µã€‚

## ğŸ” è®¤è¯ä¸æˆæƒ

### JWT è®¤è¯æµç¨‹

```
â”Œâ”€â”€â”€â”€â”€â”€â”                                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚Clientâ”‚                                â”‚ Server â”‚
â””â”€â”€â”€â”¬â”€â”€â”˜                                â””â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
    â”‚                                       â”‚
    â”‚  POST /api/auth/login                â”‚
    â”‚  {username, password}                â”‚
    â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚
    â”‚                                       â”‚
    â”‚                                       â”œâ”€â–º éªŒè¯ç”¨æˆ·åå¯†ç 
    â”‚                                       â”œâ”€â–º ç”Ÿæˆ JWT Token
    â”‚                                       â”œâ”€â–º ç¼“å­˜ç”¨æˆ·æƒé™åˆ° Redis
    â”‚                                       â”‚
    â”‚  â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â”€â”€â”‚
    â”‚  {accessToken, refreshToken, user}  â”‚
    â”‚                                       â”‚
    â”‚  GET /api/users (å¸¦ Token)           â”‚
    â”‚  Header: Authorization: Bearer xxx   â”‚
    â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–ºâ”‚
    â”‚                                       â”‚
    â”‚                                       â”œâ”€â–º éªŒè¯ Token
    â”‚                                       â”œâ”€â–º æ£€æŸ¥ Token é»‘åå•
    â”‚                                       â”œâ”€â–º éªŒè¯æƒé™
    â”‚                                       â”‚
    â”‚  â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

â”€â”€â”‚
    â”‚  {data: [...]}                       â”‚
    â”‚                                       â”‚
```

### å®ç°ç™»å½•åŠŸèƒ½

#### 1. ç™»å½•æ¥å£

```typescript
// auth.controller.ts
@Public()  // æ ‡è®°ä¸ºå…¬å¼€æ¥å£
@Post('login')
async login(@Body() loginDto: LoginDto): Promise<LoginResponseDto> {
  return this.authService.login(loginDto)
}
```

#### 2. ç™»å½•æœåŠ¡

```typescript
// auth.service.ts
async login(loginDto: LoginDto): Promise<LoginResponseDto> {
  // 1. æŸ¥æ‰¾ç”¨æˆ·
  const user = await this.userRepository.findOne({
    where: { username: loginDto.username },
    relations: ['roles', 'roles.permissions']
  })

  if (!user) {
    throw new BusinessException('ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯', 'AUTH_FAILED')
  }

  // 2. éªŒè¯å¯†ç ï¼ˆSHA-256ï¼‰
  const hashedPassword = createHash('sha256')
    .update(loginDto.password)
    .digest('hex')

  if (user.password !== hashedPassword) {
    throw new BusinessException('ç”¨æˆ·åæˆ–å¯†ç é”™è¯¯', 'AUTH_FAILED')
  }

  // 3. ç”Ÿæˆ Token
  const payload = { sub: user.id, username: user.username }
  const accessToken = this.jwtService.sign(payload)
  const refreshToken = this.jwtService.sign(payload, { expiresIn: '7d' })

  // 4. ç¼“å­˜ç”¨æˆ·æƒé™åˆ° Redisï¼ˆ1å°æ—¶ï¼‰
  await this.userPermissionsService.cacheUserPermissions(user)

  return {
    accessToken,
    refreshToken,
    user: {
      id: user.id,
      username: user.username,
      avatarUrl: user.avatarUrl
    }
  }
}
```

### å—ä¿æŠ¤çš„è·¯ç”±

```typescript
@Controller('users')
@UseGuards(JwtAuthGuard, PermissionsGuard) // åº”ç”¨å®ˆå«
export class UsersController {
  // éœ€è¦ user.read æƒé™
  @Get()
  @RequirePermissions('user.read')
  async findAll() {
    return this.usersService.findAll()
  }

  // éœ€è¦ user.create æƒé™
  @Post()
  @RequirePermissions('user.create')
  async create(@Body() dto: CreateUserDto) {
    return this.usersService.create(dto)
  }

  // éœ€è¦å¤šä¸ªæƒé™ï¼ˆAND å…³ç³»ï¼‰
  @Put(':id')
  @RequirePermissions('user.read', 'user.update')
  async update(@Param('id') id: string, @Body() dto: UpdateUserDto) {
    return this.usersService.update(+id, dto)
  }
}
```

### è·å–å½“å‰ç”¨æˆ·

```typescript
@Get('profile')
@UseGuards(JwtAuthGuard)
async getProfile(@CurrentUser() user: CurrentUserDto) {
  // user åŒ…å«ï¼šid, username, tokenIssuedAt
  return this.usersService.findOne(user.id)
}
```

## ğŸ›¡ï¸ RBAC æƒé™ç³»ç»Ÿ

### æƒé™å‘½åè§„èŒƒ

```
<èµ„æº>.<æ“ä½œ>

èµ„æºç±»å‹ï¼š
- userï¼ˆç”¨æˆ·ï¼‰
- roleï¼ˆè§’è‰²ï¼‰
- permissionï¼ˆæƒé™ï¼‰
- project-spaceï¼ˆé¡¹ç›®ç©ºé—´ï¼‰
- projectï¼ˆé¡¹ç›®ï¼‰
- project-assetï¼ˆé¡¹ç›®èµ„æºï¼‰

æ“ä½œç±»å‹ï¼š
- readï¼ˆæŸ¥çœ‹ï¼‰
- createï¼ˆåˆ›å»ºï¼‰
- updateï¼ˆæ›´æ–°ï¼‰
- deleteï¼ˆåˆ é™¤ï¼‰
- publishï¼ˆå‘å¸ƒï¼Œç‰¹æ®Šæ“ä½œï¼‰

ç¤ºä¾‹ï¼š
âœ… user.read
âœ… project.create
âœ… project.publish
âŒ readUser
âŒ CreateProject
```

### åˆ›å»ºæ–°æƒé™

```typescript
// 1. åœ¨æ•°æ®åº“æ·»åŠ æƒé™
const permission = await permissionRepository.save({
  code: 'document.export',
  name: 'å¯¼å‡ºæ–‡æ¡£',
  description: 'å¯¼å‡ºæ–‡æ¡£ä¸º PDF æˆ– Word æ ¼å¼'
})

// 2. åˆ†é…ç»™è§’è‰²
const adminRole = await roleRepository.findOne({
  where: { name: 'admin' },
  relations: ['permissions']
})

adminRole.permissions.push(permission)
await roleRepository.save(adminRole)
```

### æƒé™æ£€æŸ¥æµç¨‹

```typescript
// permissions.guard.ts
@Injectable()
export class PermissionsGuard implements CanActivate {
  async canActivate(context: ExecutionContext): Promise<boolean> {
    // 1. è·å–æ‰€éœ€æƒé™ï¼ˆä»è£…é¥°å™¨ï¼‰
    const requiredPermissions = this.reflector.getAllAndOverride<string[]>(PERMISSIONS_KEY, [
      context.getHandler(),
      context.getClass()
    ])

    if (!requiredPermissions) {
      return true // æ²¡æœ‰æƒé™è¦æ±‚ï¼Œå…è®¸è®¿é—®
    }

    // 2. è·å–å½“å‰ç”¨æˆ·
    const request = context.switchToHttp().getRequest()
    const user = request.user

    // 3. ä» Redis è·å–ç”¨æˆ·æƒé™ï¼ˆå¸¦ç¼“å­˜ï¼‰
    const userPermissions = await this.userPermissionsService.getUserPermissionCodes(user.id)

    // 4. æ£€æŸ¥æƒé™ï¼ˆAND å…³ç³»ï¼‰
    return requiredPermissions.every((permission) => userPermissions.includes(permission))
  }
}
```

### æƒé™ç¼“å­˜ç­–ç•¥

```typescript
// user-permissions.service.ts
async getUserPermissionCodes(userId: number): Promise<string[]> {
  const cacheKey = `user:${userId}:permissions`

  // 1. å°è¯•ä» Redis è·å–
  const cached = await this.cacheManager.get<string[]>(cacheKey)
  if (cached) {
    return cached
  }

  // 2. ä»æ•°æ®åº“æŸ¥è¯¢
  const user = await this.userRepository.findOne({
    where: { id: userId },
    relations: ['roles', 'roles.permissions']
  })

  const permissions = user.roles
    .flatMap(role => role.permissions)
    .map(p => p.code)

  // 3. å»é‡å¹¶ç¼“å­˜ï¼ˆ1å°æ—¶ï¼‰
  const uniquePermissions = [...new Set(permissions)]
  await this.cacheManager.set(cacheKey, uniquePermissions, 3600)

  return uniquePermissions
}
```

## ğŸ“Š æ•°æ®éªŒè¯

### ä½¿ç”¨ class-validator

```typescript
// create-user.dto.ts
import { IsString, IsOptional, MinLength, MaxLength } from 'class-validator'

export class CreateUserDto {
  @IsString({ message: 'ç”¨æˆ·åå¿…é¡»æ˜¯å­—ç¬¦ä¸²' })
  @MinLength(2, { message: 'ç”¨æˆ·åè‡³å°‘éœ€è¦2ä¸ªå­—ç¬¦' })
  @MaxLength(20, { message: 'ç”¨æˆ·åæœ€å¤š20ä¸ªå­—ç¬¦' })
  username: string

  @IsString()
  @MinLength(6, { message: 'å¯†ç è‡³å°‘éœ€è¦6ä¸ªå­—ç¬¦' })
  password: string

  @IsOptional()
  @IsString()
  avatarUrl?: string
}
```

### è‡ªå®šä¹‰éªŒè¯å™¨

```typescript
// is-unique-username.validator.ts
import { registerDecorator, ValidationOptions, ValidationArguments } from 'class-validator'
import { Injectable } from '@nestjs/common'
import { InjectRepository } from '@nestjs/typeorm'
import { Repository } from 'typeorm'
import { User } from '../entities/user.entity'

export function IsUniqueUsername(validationOptions?: ValidationOptions) {
  return function (object: Object, propertyName: string) {
    registerDecorator({
      name: 'isUniqueUsername',
      target: object.constructor,
      propertyName: propertyName,
      options: validationOptions,
      validator: {
        async validate(value: any, args: ValidationArguments) {
          const repository = args.object['userRepository']
          const existingUser = await repository.findOne({ where: { username: value } })
          return !existingUser
        },
        defaultMessage(args: ValidationArguments) {
          return 'ç”¨æˆ·åå·²å­˜åœ¨'
        }
      }
    })
  }
}
```

### éªŒè¯ç»„

```typescript
export class UpdateUserDto {
  @IsString()
  @MinLength(2, { groups: ['create'] })  // åªåœ¨åˆ›å»ºæ—¶éªŒè¯
  username?: string

  @IsString()
  @MinLength(6, { groups: ['create', 'update-password'] })  // åˆ›å»ºå’Œä¿®æ”¹å¯†ç æ—¶éªŒè¯
  password?: string
}

// ä½¿ç”¨
@Post()
async create(@Body(new ValidationPipe({ groups: ['create'] })) dto: UpdateUserDto) {
  // ...
}
```

## ğŸ—„ï¸ æ•°æ®åº“æ“ä½œ

### ä½¿ç”¨ BaseService

æ‰€æœ‰ Service éƒ½ç»§æ‰¿è‡ª `BaseService`ï¼Œæä¾›é€šç”¨ CRUD æ–¹æ³•ï¼š

```typescript
// users.service.ts
@Injectable()
export class UsersService extends BaseService<User> {
  constructor(
    @InjectRepository(User)
    userRepository: Repository<User>
  ) {
    super(userRepository)
  }

  // ç»§æ‰¿çš„æ–¹æ³•ï¼š
  // - findAll()
  // - findOne(id)
  // - create(dto)
  // - update(id, dto)
  // - softDelete(id)  â† è½¯åˆ é™¤
  // - hardDelete(id)  â† ç‰©ç†åˆ é™¤
  // - restore(id)     â† æ¢å¤è½¯åˆ é™¤
}
```

### è½¯åˆ é™¤

```typescript
// è½¯åˆ é™¤ç”¨æˆ·
await usersService.softDelete(userId)

// æŸ¥è¯¢æ—¶è‡ªåŠ¨æ’é™¤è½¯åˆ é™¤çš„è®°å½•
const users = await userRepository.find() // ä¸åŒ…å«å·²åˆ é™¤çš„

// æŸ¥è¯¢åŒ…å«è½¯åˆ é™¤çš„è®°å½•
const allUsers = await userRepository.find({ withDeleted: true })

// æ¢å¤è½¯åˆ é™¤çš„ç”¨æˆ·
await usersService.restore(userId)
```

### äº‹åŠ¡å¤„ç†

```typescript
// ä½¿ç”¨ TypeORM äº‹åŠ¡
async transferRole(fromUserId: number, toUserId: number, roleId: number) {
  return await this.dataSource.transaction(async manager => {
    // åœ¨äº‹åŠ¡ä¸­æ‰§è¡Œå¤šä¸ªæ“ä½œ
    const fromUser = await manager.findOne(User, {
      where: { id: fromUserId },
      relations: ['roles']
    })

    const toUser = await manager.findOne(User, {
      where: { id: toUserId },
      relations: ['roles']
    })

    const role = await manager.findOne(Role, { where: { id: roleId } })

    // ç§»é™¤è§’è‰²
    fromUser.roles = fromUser.roles.filter(r => r.id !== roleId)
    await manager.save(fromUser)

    // æ·»åŠ è§’è‰²
    toUser.roles.push(role)
    await manager.save(toUser)

    // æ¸…é™¤ä¸¤ä¸ªç”¨æˆ·çš„æƒé™ç¼“å­˜
    await this.userPermissionsService.clearUserPermissionsCache(fromUserId)
    await this.userPermissionsService.clearUserPermissionsCache(toUserId)
  })
}
```

### å¤æ‚æŸ¥è¯¢

```typescript
// åˆ†é¡µæŸ¥è¯¢
async findAllWithPagination(query: QueryUserDto) {
  const queryBuilder = this.repository
    .createQueryBuilder('user')
    .leftJoinAndSelect('user.roles', 'roles')
    .where('user.deletedAt IS NULL')

  // æ¡ä»¶è¿‡æ»¤
  if (query.username) {
    queryBuilder.andWhere('user.username LIKE :username', {
      username: `%${query.username}%`
    })
  }

  if (query.role) {
    queryBuilder.andWhere('roles.name = :role', { role: query.role })
  }

  // åˆ†é¡µ
  const page = query.page || 1
  const limit = query.limit || 10
  queryBuilder.skip((page - 1) * limit).take(limit)

  // æ‰§è¡ŒæŸ¥è¯¢
  const [items, total] = await queryBuilder.getManyAndCount()

  return {
    items,
    total,
    page,
    limit,
    totalPages: Math.ceil(total / limit)
  }
}
```

## ğŸš¨ å¼‚å¸¸å¤„ç†

### ä¸šåŠ¡å¼‚å¸¸

```typescript
// æŠ›å‡ºä¸šåŠ¡å¼‚å¸¸
throw new BusinessException('ç”¨æˆ·åå·²å­˜åœ¨', 'USERNAME_EXISTS')

// å¸¦ HTTP çŠ¶æ€ç 
throw new BusinessException('æ— æƒè®¿é—®', 'FORBIDDEN', HttpStatus.FORBIDDEN)
```

### å…¨å±€å¼‚å¸¸è¿‡æ»¤å™¨

```typescript
// all-exceptions.filter.ts
@Catch()
export class AllExceptionsFilter implements ExceptionFilter {
  catch(exception: unknown, host: ArgumentsHost) {
    const ctx = host.switchToHttp()
    const response = ctx.getResponse()
    const request = ctx.getRequest()

    let status = HttpStatus.INTERNAL_SERVER_ERROR
    let message = 'Internal server error'
    let error = 'INTERNAL_ERROR'

    if (exception instanceof BusinessException) {
      status = exception.getStatus()
      message = exception.message
      error = exception.getErrorCode()
    } else if (exception instanceof HttpException) {
      status = exception.getStatus()
      message = exception.message
    }

    // è®°å½•æ—¥å¿—
    this.logger.error(`${request.method} ${request.url}`, exception)

    // è¿”å›ç»Ÿä¸€æ ¼å¼
    response.status(status).json({
      code: status,
      message,
      error,
      timestamp: new Date().toISOString(),
      path: request.url
    })
  }
}
```

## ğŸ“ æ—¥å¿—è®°å½•

### ä½¿ç”¨ Logger

```typescript
// æ³¨å…¥ Logger
constructor(
  private readonly logger: LoggerService
) {}

// è®°å½•æ—¥å¿—
this.logger.log('ç”¨æˆ·ç™»å½•æˆåŠŸ', { userId: user.id })
this.logger.error('æ•°æ®åº“è¿æ¥å¤±è´¥', error)
this.logger.warn('Token å³å°†è¿‡æœŸ', { userId: user.id, expiresIn: '5m' })
this.logger.debug('è°ƒè¯•ä¿¡æ¯', { data: complexObject })
```

### æ—¥å¿—çº§åˆ«

- `error` - é”™è¯¯ï¼ˆä¼šè®°å½•åˆ° error æ–‡ä»¶ï¼‰
- `warn` - è­¦å‘Š
- `log` / `info` - ä¿¡æ¯
- `debug` - è°ƒè¯•ï¼ˆç”Ÿäº§ç¯å¢ƒä¸è¾“å‡ºï¼‰

## ğŸ”„ é˜Ÿåˆ—ä»»åŠ¡ï¼ˆBullMQï¼‰

### æ·»åŠ ä»»åŠ¡åˆ°é˜Ÿåˆ—

```typescript
// å‘é€æ¬¢è¿é‚®ä»¶
await this.emailQueue.add(JOB_TYPES.SEND_WELCOME_EMAIL, {
  email: user.email,
  username: user.username
})

// å»¶è¿Ÿä»»åŠ¡
await this.emailQueue.add(
  JOB_TYPES.SEND_REMINDER,
  { userId: user.id },
  { delay: 86400000 } // 24å°æ—¶åæ‰§è¡Œ
)
```

### å¤„ç†é˜Ÿåˆ—ä»»åŠ¡

```typescript
// email.processor.ts
@Processor(QUEUE_NAMES.EMAIL)
export class EmailProcessor {
  @Process(JOB_TYPES.SEND_WELCOME_EMAIL)
  async handleWelcomeEmail(job: Job) {
    const { email, username } = job.data

    // å‘é€é‚®ä»¶é€»è¾‘
    await this.emailService.sendWelcomeEmail(email, username)

    return { sent: true }
  }

  @OnQueueCompleted()
  onCompleted(job: Job, result: any) {
    this.logger.log(`Job ${job.id} completed with result`, result)
  }

  @OnQueueFailed()
  onFailed(job: Job, error: Error) {
    this.logger.error(`Job ${job.id} failed`, error)
  }
}
```

## ğŸ§ª æµ‹è¯•

### å•å…ƒæµ‹è¯•

```typescript
describe('UsersService', () => {
  let service: UsersService
  let repository: Repository<User>

  beforeEach(async () => {
    const module = await Test.createTestingModule({
      providers: [
        UsersService,
        {
          provide: getRepositoryToken(User),
          useValue: {
            find: jest.fn(),
            findOne: jest.fn(),
            save: jest.fn()
          }
        }
      ]
    }).compile()

    service = module.get<UsersService>(UsersService)
    repository = module.get<Repository<User>>(getRepositoryToken(User))
  })

  it('should find all users', async () => {
    const users = [{ id: 1, username: 'test' }]
    jest.spyOn(repository, 'find').mockResolvedValue(users)

    expect(await service.findAll()).toEqual(users)
  })
})
```

### API æµ‹è¯•ï¼ˆBrunoï¼‰

å‚è€ƒ `bruno-api-tests/` ç›®å½•ä¸­çš„æµ‹è¯•ç”¨ä¾‹ã€‚

## ğŸ“š ç›¸å…³æ–‡æ¡£

- [å¿«é€Ÿå¼€å§‹](./å¿«é€Ÿå¼€å§‹.md)
- [é¡¹ç›®ç»“æ„](./é¡¹ç›®ç»“æ„.md)
- [API æ–‡æ¡£](./APIæ¥å£.md)
- [éƒ¨ç½²æŒ‡å—](./éƒ¨ç½²æŒ‡å—.md)
