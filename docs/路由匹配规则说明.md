# NestJS 路由匹配规则说明

## 问题描述

NestJS 按照路由定义的**顺序**进行匹配。参数化路由（如 `:id`）会匹配任何路径段，导致具体路径无法访问。

## 所有 HTTP 方法都会遇到此问题

```typescript
// ❌ 错误示例 - 所有方法都会遇到
@Get(':id')              // 会匹配 GET /users/profile
@Get('profile')          // 永远不会被匹配到

@Post(':id')             // 会匹配 POST /users/batch
@Post('batch')           // 永远不会被匹配到

@Put(':id')              // 会匹配 PUT /users/change-password
@Put('change-password')  // 永远不会被匹配到

@Delete(':id')           // 会匹配 DELETE /users/all
@Delete('all')           // 永远不会被匹配到

@Patch(':id')            // 会匹配 PATCH /users/status
@Patch('status')         // 永远不会被匹配到
```

## 推荐解决方案

### 方案 1：调整路由顺序（临时方案）

具体路径必须在参数化路由之前定义：

```typescript
@Controller('users')
export class UsersController {
  // ✅ 正确顺序
  @Get('profile')          // 1. 具体路径在前
  @Get('online')
  @Get('statistics')
  @Get(':id')              // 2. 参数化路由在后

  @Post('batch')           // 1. 具体路径在前
  @Post('import')
  @Post(':id/validate')    // 2. 子资源路由
  @Post()                  // 3. 集合创建

  @Put('change-password')  // 1. 具体路径在前
  @Put('bulk-update')
  @Put(':id')              // 2. 参数化路由在后
}
```

**缺点**：需要手动维护顺序，容易出错。

### 方案 2：使用路径前缀（推荐）⭐

为特殊操作添加统一前缀，避免冲突：

```typescript
@Controller('users')
export class UsersController {
  // 无需关心顺序，路径上已明确区分

  @Get('actions/profile')          // GET /users/actions/profile
  @Get('actions/statistics')       // GET /users/actions/statistics
  @Get(':id')                      // GET /users/:id

  @Post('actions/batch')           // POST /users/actions/batch
  @Post('actions/import')          // POST /users/actions/import
  @Post()                          // POST /users

  @Put('actions/change-password')  // PUT /users/actions/change-password
  @Put('actions/bulk-update')      // PUT /users/actions/bulk-update
  @Put(':id')                      // PUT /users/:id
}
```

**优点**：

- ✅ 不需要考虑定义顺序
- ✅ API 语义清晰
- ✅ 易于维护和扩展

### 方案 3：使用特殊标识符

使用 `me` 或 `self` 等特殊标识符代表当前用户：

```typescript
@Controller('users')
export class UsersController {
  @Get('me')                  // GET /users/me - 获取当前用户
  @Get('me/profile')          // GET /users/me/profile
  @Put('me/password')         // PUT /users/me/password - 修改自己的密码

  @Get(':id')                 // GET /users/:id - 获取指定用户
  @Put(':id')                 // PUT /users/:id
  @Put(':id/password')        // PUT /users/:id/password - 管理员修改用户密码
}
```

在 Guard 或 Interceptor 中特殊处理 `me`：

```typescript
@Get(':id')
async getUser(@Param('id') id: string, @CurrentUser() currentUser: CurrentUserDto) {
  const userId = id === 'me' ? currentUser.id : parseInt(id);
  return this.usersService.findOne(userId);
}
```

### 方案 4：使用子控制器

将特殊操作拆分到独立的控制器：

```typescript
// users.controller.ts - 基本 CRUD
@Controller('users')
export class UsersController {
  @Get(':id')
  @Put(':id')
  @Delete(':id')
}

// user-actions.controller.ts - 特殊操作
@Controller('users/actions')
export class UserActionsController {
  @Put('change-password')      // PUT /users/actions/change-password
  @Post('batch-create')        // POST /users/actions/batch-create
  @Get('statistics')           // GET /users/actions/statistics
}
```

### 方案 5：使用不同的 HTTP 方法

利用 HTTP 语义区分操作：

```typescript
@Controller('users')
export class UsersController {
  // RESTful 标准 CRUD
  @Get(':id')       // 获取
  @Put(':id')       // 完整替换
  @Delete(':id')    // 删除

  // 特殊操作使用 PATCH
  @Patch('change-password')     // 修改密码
  @Patch('update-avatar')       // 更新头像
  @Patch(':id/status')          // 更新状态
}
```

## 推荐的命名规范

### RESTful 最佳实践

```typescript
@Controller('users')
export class UsersController {
  // ===== 集合操作 =====
  @Get()                        // GET /users - 列表
  @Post()                       // POST /users - 创建

  // ===== 具体资源操作（放在参数化路由前）=====
  @Get('me')                    // GET /users/me - 当前用户
  @Put('me/password')           // PUT /users/me/password

  // ===== 批量操作（使用 actions 前缀）=====
  @Post('actions/batch')        // POST /users/actions/batch
  @Delete('actions/bulk')       // DELETE /users/actions/bulk

  // ===== 统计和聚合（使用 stats 或 actions 前缀）=====
  @Get('stats/online')          // GET /users/stats/online
  @Get('stats/count')           // GET /users/stats/count

  // ===== 参数化路由（放在最后）=====
  @Get(':id')                   // GET /users/:id
  @Put(':id')                   // PUT /users/:id
  @Delete(':id')                // DELETE /users/:id

  // ===== 子资源操作 =====
  @Get(':id/roles')             // GET /users/:id/roles
  @Put(':id/roles')             // PUT /users/:id/roles
  @Get(':id/permissions')       // GET /users/:id/permissions
}
```

## 路径前缀建议

- `actions/` - 特殊操作（批量、导入、导出等）
- `stats/` 或 `statistics/` - 统计信息
- `me/` 或 `self/` - 当前用户相关
- `admin/` - 管理员专用操作
- `public/` - 公开信息

## 总结

1. **所有 HTTP 方法**（GET、POST、PUT、DELETE、PATCH 等）都会遇到路由匹配顺序问题
2. **最佳实践**：使用路径前缀（如 `actions/`、`me/`）来区分特殊操作和 CRUD 操作
3. **临时方案**：确保具体路径的路由定义在参数化路由之前
4. **长期方案**：制定团队的路由命名规范，统一使用前缀或特殊标识符

选择方案时考虑：

- API 的 RESTful 程度
- 团队开发习惯
- 前端调用便利性
- 长期维护成本
