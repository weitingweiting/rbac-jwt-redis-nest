# 代理转发服务

## 概述

代理转发服务（Proxy Service）为低代码平台提供统一的第三方服务转发功能。前端通过本服务作为中间层，安全地访问第三方 API，避免跨域问题和前端暴露敏感信息。

## 架构流程

```
┌─────────────┐      ┌──────────────┐      ┌──────────────────┐
│   前端页面   │ ───> │  Nest 代理服务 │ ───> │  第三方 API 服务  │
│ (低代码平台) │ <─── │   /api/v1/proxy │ <─── │  (目标服务)      │
└─────────────┘      └──────────────┘      └──────────────────┘
```

### 请求流程

1. **前端配置组件数据源**
   - 在 `sceneJson.requestGlobalConfig.requestOriginUrl` 配置目标服务 host（如：`https://api.example.com`）
   - 在 `sceneJson.componentList[].request.requestUrl` 配置接口路径（如：`/users`）

2. **前端发送代理请求**

   ```typescript
   axiosInstance({
     url: '/proxy',
     method: 'POST',
     data: {
       targetUrl: 'https://api.example.com/users',
       targetMethod: 'GET',
       targetParams: { page: 1, size: 10 },
       targetHeaders: { 'X-API-Key': 'secret' }
     }
   })
   ```

3. **代理服务转发请求**
   - 验证用户身份（JWT）
   - 验证目标 URL 白名单
   - 转发请求到第三方服务
   - 返回响应给前端

## API 接口

### POST /api/v1/proxy

代理转发接口，将请求转发到指定的目标服务。

**认证方式**：JWT Bearer Token（自动由全局守卫处理）

**请求体**：

```typescript
{
  // 目标服务的完整 URL（必填）
  targetUrl: string          // 例如：'https://api.example.com/users'

  // 目标服务的 HTTP 方法（可选，默认 GET）
  targetMethod?: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH' | 'HEAD' | 'OPTIONS'

  // 目标服务的请求体数据（可选，用于 POST/PUT/PATCH）
  targetData?: Record<string, any>

  // 目标服务的查询参数（可选，用于 GET）
  targetParams?: Record<string, any>

  // 目标服务需要的请求头（可选）
  targetHeaders?: Record<string, string>
}
```

**响应**：直接返回目标服务的响应数据

**示例**：

```typescript
// 请求示例 1：GET 请求
POST /api/v1/proxy
Authorization: Bearer <your-jwt-token>
Content-Type: application/json

{
  "targetUrl": "https://api.github.com/users/octocat",
  "targetMethod": "GET",
  "targetHeaders": {
    "Accept": "application/vnd.github.v3+json"
  }
}

// 请求示例 2：POST 请求
POST /api/v1/proxy
Authorization: Bearer <your-jwt-token>
Content-Type: application/json

{
  "targetUrl": "https://api.example.com/users",
  "targetMethod": "POST",
  "targetData": {
    "name": "John Doe",
    "email": "john@example.com"
  },
  "targetHeaders": {
    "X-API-Key": "your-api-key"
  }
}
```

## 环境变量配置

在 `.env` 文件中配置代理服务参数：

```bash
# 代理服务配置
# 允许的目标域名白名单（多个域名用逗号分隔，支持通配符）
# 开发环境：留空表示允许所有域名（不推荐生产环境）
# 生产环境：必须配置具体的域名白名单
PROXY_ALLOWED_DOMAINS=api.example.com,*.third-party.com

# 代理请求超时时间（毫秒），默认 30000ms (30秒)
PROXY_TIMEOUT=30000

# 最大重试次数，默认 0（不重试）
PROXY_MAX_RETRIES=0
```

### 域名白名单配置

支持两种格式：

1. **精确匹配**：`api.example.com`
2. **通配符匹配**：`*.example.com`（匹配所有 example.com 的子域名）

示例：

```bash
# 允许多个域名
PROXY_ALLOWED_DOMAINS=api.example.com,data.example.com,*.third-party.com

# 开发环境允许所有域名（留空）
PROXY_ALLOWED_DOMAINS=
```

## 安全特性

### 1. 身份认证

- 所有代理请求必须携带有效的 JWT Token
- 通过全局 `JwtAuthGuard` 自动验证

### 2. 域名白名单

- 生产环境必须配置 `PROXY_ALLOWED_DOMAINS`
- 防止代理服务被滥用访问任意网站
- 支持精确匹配和通配符匹配

### 3. 请求超时控制

- 默认 30 秒超时，防止长时间挂起
- 可通过环境变量配置

### 4. 日志记录

- 记录所有代理请求（目标 URL、用户 ID、状态码）
- 记录所有错误和异常
- 便于审计和排查问题

### 5. 错误处理

- 统一的错误处理机制
- 网络错误、超时错误、目标服务错误分类处理
- 返回友好的错误提示

## 前端集成示例

### 1. 基础用法

```typescript
import axios from 'axios'

// 创建 axios 实例
const axiosInstance = axios.create({
  baseURL: 'https://your-nest-server.com/api/v1',
  timeout: 30000
})

// 添加认证拦截器
axiosInstance.interceptors.request.use((config) => {
  const token = localStorage.getItem('access_token')
  if (token) {
    config.headers.Authorization = `Bearer ${token}`
  }
  return config
})

// 代理请求函数
async function proxyRequest(
  targetUrl: string,
  options: {
    method?: string
    data?: any
    params?: any
    headers?: any
  }
) {
  return axiosInstance({
    url: '/proxy',
    method: 'POST',
    data: {
      targetUrl,
      targetMethod: options.method || 'GET',
      targetData: options.data,
      targetParams: options.params,
      targetHeaders: options.headers
    }
  })
}

// 使用示例
const response = await proxyRequest('https://api.github.com/users/octocat', {
  method: 'GET',
  headers: {
    Accept: 'application/vnd.github.v3+json'
  }
})
console.log(response.data)
```

### 2. 与 sceneJson 集成

```typescript
// sceneJson 中的配置
const sceneJson = {
  requestGlobalConfig: {
    requestOriginUrl: 'https://api.example.com' // 全局 host
    // ...
  },
  componentList: [
    {
      request: {
        requestUrl: '/users', // 接口路径
        requestHttpType: 'get',
        requestParams: {
          Params: { page: 1 }
        }
      }
    }
  ]
}

// 发送请求
const component = sceneJson.componentList[0]
const targetFullUrl = sceneJson.requestGlobalConfig.requestOriginUrl + component.request.requestUrl

const response = await axiosInstance({
  url: '/proxy',
  method: 'POST',
  data: {
    targetUrl: targetFullUrl,
    targetMethod: component.request.requestHttpType.toUpperCase(),
    targetParams: component.request.requestParams.Params
  }
})
```

## Bruno API 测试示例

创建 Bruno 测试文件：`bruno-api-tests/Proxy/01-proxy-get-request.bru`

```
meta {
  name: 代理 GET 请求
  type: http
  seq: 1
}

post {
  url: {{base_url}}/proxy
  body: json
  auth: bearer
}

auth:bearer {
  token: {{access_token}}
}

body:json {
  {
    "targetUrl": "https://api.github.com/users/octocat",
    "targetMethod": "GET",
    "targetHeaders": {
      "Accept": "application/vnd.github.v3+json"
    }
  }
}

tests {
  test("状态码应为 200", function() {
    expect(res.status).to.equal(200)
  })

  test("应返回用户数据", function() {
    expect(res.body).to.have.property('login')
    expect(res.body.login).to.equal('octocat')
  })
}
```

## 错误处理

### 常见错误码

| HTTP 状态码 | 说明                              |
| ----------- | --------------------------------- |
| 400         | 请求参数错误或目标 URL 不在白名单 |
| 401         | 未授权（JWT Token 无效或缺失）    |
| 408         | 请求超时                          |
| 502         | 无法连接到目标服务                |
| 500         | 服务器内部错误                    |
| 4xx/5xx     | 目标服务返回的错误                |

### 错误响应示例

```json
{
  "statusCode": 400,
  "message": "目标域名 malicious.com 不在允许的白名单内",
  "error": "Bad Request"
}
```

```json
{
  "statusCode": 502,
  "message": "无法连接到目标服务，请检查网络或目标服务是否可用",
  "error": "Bad Gateway"
}
```

## 性能优化建议

1. **缓存策略**：对于不经常变化的数据，可以在前端或后端添加缓存
2. **批量请求**：如果需要请求多个接口，考虑在目标服务侧提供批量接口
3. **超时配置**：根据目标服务的响应时间合理配置超时时间
4. **重试机制**：对于关键业务，可以启用重试机制（配置 `PROXY_MAX_RETRIES`）

## 生产环境部署清单

- [ ] 配置 `PROXY_ALLOWED_DOMAINS` 白名单（必须）
- [ ] 根据实际情况调整 `PROXY_TIMEOUT`
- [ ] 确保 JWT 认证正常工作
- [ ] 配置日志级别为 `info` 或 `warn`
- [ ] 监控代理请求的频率和错误率
- [ ] 定期审计代理日志

## 常见问题

### Q: 为什么需要代理服务？

A:

1. 解决跨域问题（CORS）
2. 统一管理和认证
3. 隐藏第三方服务的认证信息（如 API Key）
4. 日志记录和审计
5. 安全控制（白名单）

### Q: 如何处理目标服务需要特殊认证的情况？

A: 通过 `targetHeaders` 传递认证信息，例如：

```typescript
{
  targetHeaders: {
    'Authorization': 'Bearer target-service-token',
    'X-API-Key': 'target-api-key'
  }
}
```

### Q: 是否支持文件上传/下载？

A: 当前版本主要支持 JSON 数据交互。文件操作建议使用专门的 OSS 服务。

### Q: 如何调试代理请求？

A: 查看日志文件 `logs/combined-*.log`，包含所有代理请求的详细信息。

## 相关文件

- 模块：[src/modules/proxy/proxy.module.ts](../../src/modules/proxy/proxy.module.ts)
- 控制器：[src/modules/proxy/proxy.controller.ts](../../src/modules/proxy/proxy.controller.ts)
- 服务：[src/modules/proxy/proxy.service.ts](../../src/modules/proxy/proxy.service.ts)
- DTO：[src/modules/proxy/dto/proxy-request.dto.ts](../../src/modules/proxy/dto/proxy-request.dto.ts)
